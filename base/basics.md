# Базовые элементы языка
[The Rust Programming Language](https://doc.rust-lang.org/book/title-page.html)  
<a href="https://doc.rust-lang.org/book/title-page.html" target="_blank">The Rust Programming Language</a>
----

## Переменные и константы
### Простые типы данных
* Типы данных
  * Числовые
    * `i8`, `i16`, `i32`, `i64`, `i128`, `isize` знаковые целые
    * `u8`, `u16`, `u32`, `u64`, `u128`, `usize` беззнаковые целые
    *  `f32`, `f64` числа с плавающей точкой
  * Логические `bool` (`true`|`false`)
  * Символьные (отдельный символ Unicode; занимает в памяти 4 байта)
    * тип `char` — один произвольный символ
  * Текстовые (набор символов в кодировке UTF-8):
    * тип `String`
  * Массивы – хранилища фиксированного размера; содержат данные только одного типа
  * Вектора – хранилища динамически изменяемого размера; содержат данные только одного типа
  * Кортежи — наборы из объектов любого типа
      
Числовые, логические и символьный тип данных хранятся в стеке.
Текстовые переменные хранятся в куче.

### Составные типы данных
#### Кортежи
```rust
let tuple = (значение1, значение2, ... значениеN);
```
Группируют данных различных типов в один составной тип. После создания кортежа его размер и тип данных нельзя изменить.  
Для обращения к элементу кортежа используется точка и индекс элемента, напр., `tuple.2`. Индексирование в rust начинается с нуля.  
Если кортеж объявлен изменяемым, то его элементам можно присваивать другие значения.  
Кортежи хранятся в стеке только, если все его элементы могут храниться в стеке. Во всех остальных случаях кортеж сохраняется в куче.

>Константы объявляются с помощью ключевого слова `const` с обязательным указанием типа и присвоением значения, известного на момент компиляции (т.е. нельзя присвоить результат функции). Константы в отличие от переменных можно объявить в глобальной области видимости.

### Особенности использования переменных
* при создании для переменных явно указывается, должна ли она быть изменяемой (_mutable_): `mut x: i32 = 651;`
* Каждая переменная имеет единственного владельца.
* При выходе кода за область видимости переменной ее значение и владелец уничтожаются.
* При присвоении переменной другой переменной значение копируется в случае переменных, которые хранятся в стеке и меняют владельца в случае, если храняться в куче (старый владелец уничтожается).
* Для переменной `x` метод `x.clone()` создает копию переменной.
* После передачи переменной в качестве аргумента функции ее владельцем становится функция.
* Чтобы не изменять владельца переменной при передаче ее в функцию в качестве аргумента нужно использовать ссылки.
* Ссылки как и переменные могут быть изменяемыми и неизменяемыми.
* Для переменной можно создать любое количество неизменяемых ссылок. Изменяемая ссылка может быть только одна (чтобы избежать изменения значения из двух мест).
* Для переменной может быть создан только один тип ссылки - либо единственная изменяемая, либо любое количесво неизменяемых, но не те и другие вместе.
* Константы определяются с помощью ключевого слова `const`. Для присвоения значения константе в строке инициализации не может использоваться возвращаемое значение функции.

## Особенности языка
* Инструкция `loop {}` реализует бесконечный цике — выкод из него осуществлятся оператором `break`, который может возвращать значение. Если цикл возвращает значение, то после его закрывающейся фигурной скобки ставится `;`.
* Иеструкция `if let` позволяет присвоить переменной значение, полученное в результате работы условного оператора.

## Особенности использования функций
* Аргументы функции неизменяемы, если только в определении функции аргументу не предшествует ключевое слово `mut`.
* В инструкции, возвращаемой значение функции, в конце не ставится `;` и не используются никакие ключевые слова типа *return*. Если поставить `;`, то эта строка уже не будет возвращаемым значением. Как вариант – значение из функции может возвращаться с помощью оператора `return`, заканчивающегося `;`.
* Функция в rust представляет собой особый тип данных, который определяется типом аргументов функции и типом возвращаемого значения (аналог делегатов в C#). Поэтому функции могут присваиваться переменным и затем вызываться через эти переменные, а также могут являться аргументами или возвращаемыми занчениями других функций.
* Тип функции определяется выражением вида `fn(i32, i32 -> i32`.

### Анонимные функции
* Анонимные функции не имеют названия и должны сохраняться в переменную `let переменная = | параметры | {...};`.
* Анонимные функции могут возвращать значения.
* Указание типов аргументов и типа возвращаемого значения для анонимной функции не обязатльныы. Типы будут определяться при первом вызове анинимной функции и не могут быть изменены далее.
* При наличии только одной инструкции в анонимной функции фигурные скобки можно не указывать.
* Если анонимная функция должна изменять значение внешней переменной, то и эта внешняя переменная и переменная, в которую сохраняется анонимная функция должны быть опроеделнеы как изменяемые.
* 
* 
