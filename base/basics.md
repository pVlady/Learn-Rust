# Базовые элементы языка
[The Rust Programming Language](https://doc.rust-lang.org/book/title-page.html)

## Переменные и константы

### Простые типы данных
* Типы данных
  * Числовые
    * `i8`, `i16`, `i32`, `i64`, `i128`, `isize` знаковые целые
    * `u8`, `u16`, `u32`, `u64`, `u128`, `usize` беззнаковые целые
    *  `f32`, `f64` числа с плавающей точкой
  * Логические `bool` (`true`|`false`)
  * Символьные (отдельный символ Unicode; занимает в памяти 4 байта)
    * тип `char` — один произвольный символ

Числовые, логические и символьный тип данных хранятся в стеке.

>Константы объявляются с помощью ключевого слова `const` с обязательным указанием типа и присвоением значения, известного на момент компиляции (т.е. нельзя присвоить результат функции). Константы в отличие от переменных можно объявить в глобальной области видимости.

### Составные типы данных
  
#### Текстовые строки (String)
Набор символов в кодировке UTF-8. Текстовые переменные хранятся в куче.
* Выражение вида `"..."` представляет собой строковый литерал. Для преобразования его в строку нужно вызвать на нем метод `"...".to_string()`.

#### Массивы (array)
```rust
let numbers: [i32; 4] = [1, 3, 5, 21];    // при определении массива указываются тип и число элементов в нем
let numbers: [i32; 5] = [2; 5];           // создание пятиэлементного массива, запоненнго значением по умолчанию (2)
```
* Массив всегда имеет фиксированный размер, который не может быть изменен.
* Массивы содержат данные только одного типа.
* Индексация элементов массива начинается с нуля. Обращение к переменной по индексу: `numbers[2]`.

#### Кортежи (tuple)
```rust
let tuple = (значение1, значение2, ... значениеN);
```
Группируют данных различных типов в один составной тип. После создания кортежа его размер и тип данных нельзя изменить.  
Для обращения к элементу кортежа используется точка и индекс элемента, напр., `tuple.2`. Индексирование в rust начинается с нуля.  
Если кортеж объявлен изменяемым, то его элементам можно присваивать другие значения.  
Для кортежа доступна операция декомпозиции, когда каждый его элемент присваивается отдельной переменной (если какое-то значение не нужно, указывается `_`):
```rust
let (name, age, _, height) = user;
```
Кортежи можно сравнивать. Кортежи считаются равными, если равны их соответствующие значения.  
Кортежи хранятся в стеке только, если все его элементы могут храниться в стеке. Во всех остальных случаях кортеж сохраняется в куче.

#### Вектора
* Размер вектора может динамически мзменяться
* Векторы содержат данные только одного типа

#### Структуры (struct)
```rust
struct Person                    // структура - человек
{
    name: String,   // имя
    age: u8         // возраст
}

let tom = Person{                // определение переменной структурного типа Pearson
    name: "Tom".to_string(),
    age: 36,
    height: 1.78
};

let tom = Person{                // заполнение полей одной структуры, используя значения другого экземпляра структуры
    name: "Tom".to_string(),
    ..bob
};

let Person{name: username, age: userage, height: _} = tom;  // декомпозиция структуры
```
* Названия структур принято писать с большой буквы.
* Полями структуры могут быть другие структруры.
* Обращение к полю структуры производится через точку: `tom.name`.
* Если предполакается изменение значения полей структуры, она должна быть объявлена изменяемой.

#### Структуры-кортежи (tuple struct)
Для полей не указываются имена - только типы данных. Обращение к полям производится по индексу (как для кортежа).
```rust
struct название_структуры { тип_поля1, тип_поля2, ... }
```
Для обращения к элементу перечисления указывается название перечисления и через два двоеточия нужная константа.

#### Перечисления
Представляют набор констант.
```rust
enum название_перечисления { константа1, константа2, ... }
```
* Константы перечисления могут хранить некоторые значения. В этом случае тип значений указывается в круглых скобках после имени константы. При этом разные константы могуть определять различные типы данных.
* Перечисления могут быть аргументами функций.

#### Последовательности (Range)
По сути последовательность является структурой `std::ops::Range` с полями `start` и `end`.
```rust
let numbers = 1..9;
let numbers = std::ops::Range { start: 1, end: 9 };  // то же самое
let numbers = 1..=9;                                 // число 9 включается в последовательность 
```
Последовательности удобны для получения элементов из среза массива:
```rust
 for num in numbers[1..5].iter() { print!("{} ", num) }
```

### Особенности использования переменных
* при создании для переменных явно указывается, должна ли она быть изменяемой (_mutable_): `mut x: i32 = 651;`
* Каждая переменная имеет единственного владельца.
* При выходе кода за область видимости переменной ее значение и владелец уничтожаются.
* При присвоении переменной другой переменной значение копируется в случае переменных, которые хранятся в стеке и меняют владельца в случае, если храняться в куче (старый владелец уничтожается).
* Для переменной `x` метод `x.clone()` создает копию переменной.
* После передачи переменной в качестве аргумента функции ее владельцем становится функция.
* Чтобы не изменять владельца переменной при передаче ее в функцию в качестве аргумента нужно использовать ссылки.
* Ссылки как и переменные могут быть изменяемыми и неизменяемыми.
* Для переменной можно создать любое количество неизменяемых ссылок. Изменяемая ссылка может быть только одна (чтобы избежать изменения значения из двух мест).
* Для переменной может быть создан только один тип ссылки - либо единственная изменяемая, либо любое количесво неизменяемых, но не те и другие вместе.
* Константы определяются с помощью ключевого слова `const`. Для присвоения значения константе в строке инициализации не может использоваться возвращаемое значение функции.

## Особенности языка
* Инструкция `loop {}` реализует бесконечный цике — выкод из него осуществлятся оператором `break`, который может возвращать значение. Если цикл возвращает значение, то после его закрывающейся фигурной скобки ставится `;`.
* Иеструкция `if let` позволяет присвоить переменной значение, полученное в результате работы условного оператора.

## Особенности использования функций
* Аргументы функции неизменяемы, если только в определении функции аргументу не предшествует ключевое слово `mut`.
* В инструкции, возвращаемой значение функции, в конце не ставится `;` и не используются никакие ключевые слова типа *return*. Если поставить `;`, то эта строка уже не будет возвращаемым значением. Как вариант – значение из функции может возвращаться с помощью оператора `return`, заканчивающегося `;`.
* Функция в rust представляет собой особый тип данных, который определяется типом аргументов функции и типом возвращаемого значения (аналог делегатов в C#). Поэтому функции могут присваиваться переменным и затем вызываться через эти переменные, а также могут являться аргументами или возвращаемыми занчениями других функций.
* Тип функции определяется выражением вида `fn(i32, i32 -> i32`.

### Анонимные функции
* Анонимные функции не имеют названия и должны сохраняться в переменную `let переменная = | параметры | {...};`.
* Анонимные функции могут возвращать значения.
* Указание типов аргументов и типа возвращаемого значения для анонимной функции не обязатльныы. Типы будут определяться при первом вызове анинимной функции и не могут быть изменены далее.
* При наличии только одной инструкции в анонимной функции фигурные скобки можно не указывать.
* Если анонимная функция должна изменять значение внешней переменной, то и эта внешняя переменная и переменная, в которую сохраняется анонимная функция должны быть опроеделнеы как изменяемые.
* 

## References
* [Уроки по языку программирования Rust](https://www.youtube.com/playlist?list=PLQQFvHDqx-V8Qjj-oyga0tYSCKzq5DJQE)
