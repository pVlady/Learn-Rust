# Базовые элементы языка
[The Rust Programming Language](https://doc.rust-lang.org/book/title-page.html)

## Переменные и константы

### Простые типы данных
* Типы данных
  * Числовые
    * `i8`, `i16`, `i32`, `i64`, `i128`, `isize` знаковые целые
    * `u8`, `u16`, `u32`, `u64`, `u128`, `usize` беззнаковые целые
    *  `f32`, `f64` числа с плавающей точкой
  * Логические `bool` (`true`|`false`)
  * Символьные (отдельный символ Unicode; занимает в памяти 4 байта)
    * тип `char` — один произвольный символ

Числовые, логические и символьный тип данных хранятся в стеке.

>Константы объявляются с помощью ключевого слова `const` с обязательным указанием типа и присвоением значения, известного на момент компиляции (т.е. нельзя присвоить результат функции). Константы в отличие от переменных можно объявить в глобальной области видимости.

### Составные типы данных
  
#### Текстовые строки (String)
Набор символов в кодировке UTF-8. Текстовые переменные хранятся в куче.
* Выражение вида `"..."` представляет собой строковый литерал. Для преобразования его в строку нужно вызвать на нем метод `"...".to_string()`.

#### Массивы (array)
```rust
let numbers: [i32; 4] = [1, 3, 5, 21];    // при определении массива указываются тип и число элементов в нем
let numbers: [i32; 5] = [2; 5];           // создание пятиэлементного массива, запоненнго значением по умолчанию (2)
```
* Массив всегда имеет фиксированный размер, который не может быть изменен.
* Массивы содержат данные только одного типа.
* Индексация элементов массива начинается с нуля. Обращение к переменной по индексу: `numbers[2]`.

#### Кортежи (tuple)
```rust
let tuple1 = (значение1, значение2, ... значениеN);
let tuple2: (char, i32) = ('abc', 99);               // явное объявление типов элементов
tuple1.0;                                            // вернет значение1
tuple1.1;                                            // вернет значение2
```
Кортеж группирует данные различных типов в один составной тип.
* После создания кортежа его _размер_ и _тип данных_ изменить нельзя.
* Для обращения к элементу кортежа используется точка и индекс элемента, напр., `tuple.2`. Индексирование начинается с нуля.
* Если кортеж объявлен изменяемым, то его элементам можно присваивать другие значения.
* Кортежи можно сравнивать. Кортежи считаются равными, если равны их соответствующие значения.
* Кортежи хранятся в стеке только, если все его элементы могут храниться в стеке. Иначе кортеж сохраняется в куче.
* Для кортежа доступна операция декомпозиции, когда каждый его элемент присваивается отдельной переменной (если какое-то значение не нужно, указывается `_`):
```rust
let (name, age, _, height) = user;                   // удобно использовать для возвращаемого значения, если функция возвращает кортеж
```

#### Вектора
* Размер вектора может динамически мзменяться
* Векторы содержат данные только одного типа

#### Структуры (struct)
```rust
struct Person                    // объявление структуры (человек)
{
    name: String,   // имя
    age: u8         // возраст
}

let tom = Person{                // определение переменной структурного типа Pearson
    name: "Tom".to_string(),
    age: 36
};

let tom = Person{                // заполнение полей одной структуры, используя значения другого экземпляра структуры
    name: "Tom".to_string(),
    ..bob
};

let person{name: username, age: userage, height: _} = tom;  // декомпозиция структуры
```
* Названия структур принято писать с большой буквы.
* Полями структуры могут быть другие структруры.
* Обращение к полю структуры производится через точку: `tom.name`.
* Если предполакается изменение значения полей структуры, она должна быть объявлена изменяемой.

Для структуры могут бвть объявлены методы:
```rust
impl Person { 
  fn is_adult(self) -> bool { 
    self.age >= 16
  }
}
```

#### Структуры-кортежи (tuple struct)
Для полей не указываются имена - только типы данных. Обращение к полям производится по индексу (как для кортежа).
```rust
struct название_структуры { тип_поля1, тип_поля2, ... }
```
Для обращения к элементу перечисления указывается название перечисления и через два двоеточия нужная константа.

#### Перечисления
Представляют набор констант.
```rust
enum название_перечисления { константа1, константа2, ... }
```
* Константы перечисления могут хранить некоторые значения. В этом случае тип значений указывается в круглых скобках после имени константы. При этом разные константы могуть определять различные типы данных.
* Перечисления могут быть аргументами функций.

#### Последовательности (Range)
По сути последовательность является структурой `std::ops::Range` с полями `start` и `end`.
```rust
let numbers = 1..9;
let numbers = std::ops::Range { start: 1, end: 9 };  // то же самое
let numbers = 1..=9;                                 // число 9 включается в последовательность 
```
Последовательности удобны для получения элементов из среза массива:
```rust
 for num in numbers[1..5].iter() { print!("{} ", num) }
```

#### Функции
```rust
fn fair_dice_roll() -> i32 { 4 }  // в выражении, которое возвращает значение функции точка с запятой в конще не ставится (or write return 4; )
```

### Дополнительные элементы синтаксиса
```rust
let x = { 99 }                        // результат вычисления блока кода может быть присвоен переменной (то же без точки с запятой в последней инструкции)
let min_value = std::cmp::min(3, 8);  // двойное двоеточие используется для указания пространств имен
use std::cmp::min;                    // объявляет функцию для дальншейшего использования
use std::cmp::{min, max};             // аналогично для объявления нескольких функций
use std::cmp::*;                      // объявление для всех функций в указанном пространстве имен
```

### Условные операторы и циклы
`if` и `match` являются выражениями и результат может быть присвоен переменной
```rust
if cond {...} else {...}
match var_x { true => 6, false => 4, }
```

### Особенности использования переменных
* при создании для переменных явно указывается, должна ли она быть изменяемой (_mutable_): `mut x: i32 = 651;`
* Каждая переменная имеет единственного владельца.
* При выходе кода за область видимости переменной ее значение и владелец уничтожаются.
* При присвоении переменной другой переменной значение копируется в случае переменных, которые хранятся в стеке и меняют владельца в случае, если храняться в куче (старый владелец уничтожается).
* Для переменной `x` метод `x.clone()` создает копию переменной.
* После передачи переменной в качестве аргумента функции ее владельцем становится функция.
* Чтобы не изменять владельца переменной при передаче ее в функцию в качестве аргумента нужно использовать ссылки.
* Ссылки как и переменные могут быть изменяемыми и неизменяемыми.
* Для переменной можно создать любое количество неизменяемых ссылок. Изменяемая ссылка может быть только одна (чтобы избежать изменения значения из двух мест).
* Для переменной может быть создан только один тип ссылки - либо единственная изменяемая, либо любое количесво неизменяемых, но не те и другие вместе.
* Константы определяются с помощью ключевого слова `const`. Для присвоения значения константе в строке инициализации не может использоваться возвращаемое значение функции.

## Особенности языка
* Инструкция `loop {}` реализует бесконечный цике — выкод из него осуществлятся оператором `break`, который может возвращать значение. Если цикл возвращает значение, то после его закрывающейся фигурной скобки ставится `;`.
* Иеструкция `if let` позволяет присвоить переменной значение, полученное в результате работы условного оператора.

## Особенности использования функций
* Аргументы функции неизменяемы, если только в определении функции аргументу не предшествует ключевое слово `mut`.
* В инструкции, возвращаемой значение функции, в конце не ставится `;` и не используются никакие ключевые слова типа *return*. Если поставить `;`, то эта строка уже не будет возвращаемым значением. Как вариант – значение из функции может возвращаться с помощью оператора `return`, заканчивающегося `;`.
* Функция в rust представляет собой особый тип данных, который определяется типом аргументов функции и типом возвращаемого значения (аналог делегатов в C#). Поэтому функции могут присваиваться переменным и затем вызываться через эти переменные, а также могут являться аргументами или возвращаемыми занчениями других функций.
* Тип функции определяется выражением вида `fn(i32, i32 -> i32`.

### Анонимные функции
* Анонимные функции не имеют названия и должны сохраняться в переменную `let переменная = | параметры | {...};`.
* Анонимные функции могут возвращать значения.
* Указание типов аргументов и типа возвращаемого значения для анонимной функции не обязатльныы. Типы будут определяться при первом вызове анинимной функции и не могут быть изменены далее.
* При наличии только одной инструкции в анонимной функции фигурные скобки можно не указывать.
* Если анонимная функция должна изменять значение внешней переменной, то и эта внешняя переменная и переменная, в которую сохраняется анонимная функция должны быть опроеделнеы как изменяемые.
* 

## References
* [The Rust Programming Language](https://doc.rust-lang.org/book/title-page.html)
* [Руководство по языку программирования Rust](https://metanit.com/rust/tutorial/)
* [Уроки по языку программирования Rust](https://www.youtube.com/playlist?list=PLQQFvHDqx-V8Qjj-oyga0tYSCKzq5DJQE)
* [Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/intro.html)
* [Rust на примерах](https://doc.rust-lang.ru/stable/rust-by-example/index.html)
* [Маленькая книжка по макросам в Rust](https://github.com/rust-lang-ru/tlborm)
* [Растономикон](https://github.com/rust-lang-ru/nomicon)
* [Руководство по Cargo](https://rurust.github.io/cargo-docs-ru/guide.html)
* [The Cargo](https://doc.rust-lang.org/cargo/index.html)
* [The Rust Edition Guide](https://doc.rust-lang.org/edition-guide/editions/creating-a-new-project.html)
* **[A half-hour to learn Rust](https://fasterthanli.me/articles/a-half-hour-to-learn-rust)**
* [17 Resources to Help You Learn Rust in 2023](https://serokell.io/blog/learn-rust)
