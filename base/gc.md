# Управление памятью в Rust
## Владение
- Любая переменная имеет только одного *владельца*
- Операция присвоения изменяет владельца переменной
- Когда владелец переменной выходит из области видимости, переменная уничтожается

Trate — это контракт, которому должен следовать тип.\
Например, Trate `Drop` требует создания единственного метода `drop()`, который будет вызываться при уничтожении объекта. При этом компилятор самостоятельно вставит вызов этого метода в нужные места.
```rust
impl Drop for StreamOfDrop {
  fn drop(&murt self) {
    println!("Destroy {}", self.number)
  }
}
```

## Заимствование
- Это временная передача объекта
- Реализуется через ссылки
- Ссылки могут быть:
  - мутабельная (уникальная) — такая ссылка может быть только одной
  - неизменяемая (разделяемая) — таких ссылок может быть любое количество
- Компилятор гарантирует, что ссылка всегда указывает на корректные данные
- Время жизни ссылки должно быть меньше, чем время жизни объекта, который она заимствует.\
  Компилятор проверяет это условие, и если не может определить lifetime, то требует указать его явно.\
  Очевидно, что функция не может вернуть ссылку на свои локальные данные, т.к. при выходе из функции все ее локальные переменные будут уничтожены.

Пример указания глобального лайфтайма для строковой переменной: `&'static s: String = String::new();`.\
Пример 2. Использование generic для указания lifetime. В таком случае компилятор выберет для результата функции меньшее из лайфтаймов `first` и `second`:
```rust
fn some_func<'a>(first: &'a String, second: &'a String) → &'a String {...}
```

