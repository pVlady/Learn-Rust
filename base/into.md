# Введение в rust
## Особенности синтаксиса
* `&x` означает ссылку на переменную `x`
* `*y` означает переход от ссылки `y` к самой переменной. `*(&x) `даст `x`

## Простые типы данных

## Сложные типы данных
## Тип `Option`
* Может быть либо `Some` (содержащее значение любого типа), либо `None`.
* Переменная `x` типа `Option` имеет логические методы `x.is_some()`, `x.is_none()`
* Метод `x.unwrap()` вызовет панику, если `x.is_none() == true`, либо вернет значение конкретного типа, если `x.is_some() == true `.
* Метод `x.unwrap_or(&-1)` вернет знчение, если `x.is_some() == true `, либо `-1`, если `x.is_none() == true`.

### Массивы (Array)
* Содержат значения только одного типа
* Можно организовывать массивы массивов
```rust
let arr = [1, 2, 3, 4, 5]             ; массив
let arr: [i32; 5] = [1, 2, 3, 4, 5]   ; указание размера массива и типа его элементов
let numbers: [i32; 5] = [3; 5]        ; массив из 5 элементов со значениями по умолчанию равными 3
let arr = [3; 5]                      ; тоже с автоопределением типа элементов
let mut arr = [3; 5]                  ; изменяемый массив
arr[0]                                ; индексация начинается с нуля (обращение к первому элементу)

for index in 0..3 {
    println!("Index: {} |> value: {}", index, arr[index])   ; цикл по элементам массива
}
```
* По умолчанию массивы неизменяемы.

### Срезы (Slice)
Порция данных из коллекций (массивов, векторов, символьного значения).\
Срез на копирует данные, а сохраняет связь с коллекцией.
```rust
let slice = &arr[1..3]      ; 2-ой и 3-ий элементы массива (&arr - ссылка на массив)
let slice = &arr[..3]       ; все элементы с первого по третий
let slice = &arr[2..]       ; все элементы с третьего и до конца массива
let slice = &arr[2..]       ; получим все элементы массива
let slice = &mut arr[1..4]  ; изменяемый срез (можно изменить значение внутри среза - массив должен быть изменяемым)
slice.get(5)                ; получение элемента по индексу без вызова исключения (вернет объект типа `Option`)
```

### Векторы (Vector)
* По сути являются массивами с изменяемым размером, т.е. если вектор объявлен изменяемым, в него могут быть добавлены элементы.
* Оператор `&` приводит вектор к типу `Slice`.
```rust
let mut x = Vec::new();
x.push(10)
dump(&x)
```

### Кортежи (Tuple)
* Может хранить элементы разных типов.
* Имеет фиксированный размер, который не может быть изменен после инициализации.
```rust
let tuple = ('Hello', 5, 3.14)                   ; кортеж без указания типа элементов
let student_info: (&str, f32) = ("Ricky", 3.14)  ; кортеж с указанием типа элементов
println!("Tuple contents = {:?}", tuple)         ; вывод кортежа на экран
tuple.0                                          ; обращение к перваому элементу
let mut mountains = ("Everest", 8848)            ; изменяемый кортеж
let (name, height) = tuple                       ; распаковка кортежа в переменные
```

### Структуры (Struct)
* Может иметь элементы различных типов
```rust
struct Person {name: String, age: u8, height: u8}               ; объявление структуры
let person1 = Person {name: String::from("John Doe"), age: 18}  ; создание экзмепляра структуры  
person1.age                                                     ; доступ к полю структуры
let Person { name1, age1, height1 } = person1                   ; распаковка структуры в указанные переменные
```

## Ветвление и циклы
### Условные операторы
```rust
if <condition> {...} else {... }   ; скообки вокруг condition не обязхательны
```

### Циклы
```rust
for j in 0..5 { тело_цикла }
```
## Функции
```rust
fn main() { тело функции }
fn by_ref(x: &i32) -> f32 { ... }  ; передача аргумента по ссылке и возврат f32-значения
```
* Возвращаемое значение устанавливается оператором `return` либо последним выражением в теле функции, после которого НЕ СТАВИТСЯ точка с запятой.

  

## References
* [Rust | Programiz](https://www.programiz.com/rust/getting-started)
